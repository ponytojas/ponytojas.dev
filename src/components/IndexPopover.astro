---
// src/components/IndexPopover.astro
interface Props {
  links: Array<{ href: string; label: string }>;
}
const { links = [] } = Astro.props;
---

<div
  class="fixed bottom-8 w-screen flex justify-center z-50"
  data-alignment="center"
>
  <!-- Container for button + menu -->
  <div class="menu-container relative">
    <!-- Floating Menu Button/Container -->
    <div
      id="floatingMenu"
      class="relative bg-[#17171c] dark:bg-[#fafaee] rounded-full shadow-lg flex flex-col transition-all duration-300 ease-in-out overflow-hidden"
      style="width: 120px; height: 44px; border-radius: 22px;"
    >
      <!-- Button Header (always visible) -->
      <div
        class="flex items-center justify-center px-3 py-2 cursor-pointer h-[44px] min-h-[44px]"
        id="menuToggle"
      >
        <div class="flex items-center mr-2">
          <!-- Progress SVG -->
          <svg
            class="w-8 h-8"
            viewBox="0 0 100 50"
            fill="none"
            stroke-linecap="round"
          >
            <!-- Background Lines (NO progress-line class) -->
            <line
              x1="10"
              y1="10"
              x2="50"
              y2="10"
              stroke="var(--line-bg)"
              stroke-width="8"
              stroke-dasharray="40"></line>
            <line
              x1="10"
              y1="25"
              x2="65"
              y2="25"
              stroke="var(--line-bg)"
              stroke-width="8"
              stroke-dasharray="55"></line>
            <line
              x1="10"
              y1="40"
              x2="40"
              y2="40"
              stroke="var(--line-bg)"
              stroke-width="8"
              stroke-dasharray="30"></line>
            <!-- Foreground/Progress Lines (ONLY ONE class, plus data-length) -->
            <line
              class="progress-line"
              x1="10"
              y1="10"
              x2="50"
              y2="10"
              stroke="var(--line-fg)"
              stroke-width="8"
              stroke-dasharray="40"
              stroke-dashoffset="40"
              data-length="40"></line>
            <line
              class="progress-line"
              x1="10"
              y1="25"
              x2="65"
              y2="25"
              stroke="var(--line-fg)"
              stroke-width="8"
              stroke-dasharray="55"
              stroke-dashoffset="55"
              data-length="55"></line>
            <line
              class="progress-line"
              x1="10"
              y1="40"
              x2="40"
              y2="40"
              stroke="var(--line-fg)"
              stroke-width="8"
              stroke-dasharray="30"
              stroke-dashoffset="30"
              data-length="30"></line>
          </svg>
        </div>

        <span
          class="flex items-center gap-1 text-sm font-medium text-[#fafaee] dark:text-[#17171c]"
        >
          Index
          <svg
            id="arrow-icon"
            class="w-4 h-4 transform transition-transform duration-300"
            fill="none"
            stroke="currentColor"
            stroke-width="1.5"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              d="M19.5 8.25l-7.5 7.5-7.5-7.5"></path>
          </svg>
        </span>
      </div>

      <!-- Menu Items List -->
      <ul
        id="menuList"
        class="menu-list opacity-0 max-h-0 overflow-hidden w-full px-4 space-y-3 text-sm text-[#fafaee] dark:text-[#17171c] transition-all duration-300 ease-in-out"
      >
        {
          links.map((link) => (
            <li>
              <a
                href={link.href}
                class="block hover:bg-gray-700 dark:hover:bg-gray-200 dark:hover:text-[#17171c] px-2 py-1 rounded transition-colors"
                data-menu-link
              >
                {link.label}
              </a>
            </li>
          ))
        }
      </ul>
    </div>
  </div>
</div>

<!-- Styles -->
<style>
  /* Styles remain the same */
  .menu-container {
    z-index: 50;
  }
  #arrow-icon.rotated {
    transform: rotate(180deg);
  }
  .menu-list {
    transition:
      opacity 0.3s ease-in-out,
      max-height 0.3s ease-in-out,
      padding 0.3s ease-in-out;
    pointer-events: none;
  }
  .menu-list.visible {
    opacity: 1;
    pointer-events: auto;
    max-height: 500px;
    padding-top: 0.5rem;
    padding-bottom: 1rem;
  }
  /* Style the lines we intend to animate */
  line[data-length] {
    transition: stroke-dashoffset 0.1s linear;
  }
</style>

<!-- Client Script -->
<script is:inline>
  // Wrap everything in a function to avoid polluting global scope
  function setupIndexPopover() {
    console.log("[IndexPopover] Setup function called.");

    // --- Get Elements ---
    const floatingMenu = document.getElementById("floatingMenu");
    const menuToggle = document.getElementById("menuToggle");
    const menuList = document.getElementById("menuList");
    const arrowIcon = document.getElementById("arrow-icon");

    // Check main container first
    if (!floatingMenu) {
      console.error(
        "[IndexPopover] ERROR: floatingMenu element not found! Aborting."
      );
      return;
    }
    console.log("[IndexPopover] floatingMenu element found.");

    // --- Select the SVG element first ---
    console.log(
      "[IndexPopover] Attempting to find 'svg' within floatingMenu..."
    );
    const svgElement = floatingMenu.querySelector("svg");

    if (!svgElement) {
      console.error(
        "[IndexPopover] ERROR: SVG element not found within floatingMenu! Aborting."
      );
      return;
    }
    console.log("[IndexPopover] SVG element found.");

    // --- Select progress lines using getElementsByTagName and filter ---
    console.log(
      "[IndexPopover] Attempting to find <line> elements within SVG using getElementsByTagName..."
    );
    const allLines = svgElement.getElementsByTagName("line");
    console.log(
      `[IndexPopover] Found ${allLines.length} total <line> elements.`
    );

    // Filter the HTMLCollection to get only those with data-length
    // *** REMOVED TypeScript type annotation : SVGLineElement[] ***
    const progressLines = Array.from(allLines).filter((line) =>
      line.hasAttribute("data-length")
    );
    console.log(
      `[IndexPopover] Filtered down to ${progressLines.length} lines with [data-length] attribute.`
    );

    // --- Check All Elements ---
    // Check other elements AND the result of the filtered line array
    if (!menuToggle || !menuList || !arrowIcon || progressLines.length !== 3) {
      console.error(
        "[IndexPopover] ERROR: Missing essential child elements or wrong count of progress lines (expected 3 with data-length after filtering). Aborting.",
        {
          menuToggle: !!menuToggle,
          menuList: !!menuList,
          arrowIcon: !!arrowIcon,
          svgElementFound: !!svgElement,
          totalLinesFound: allLines.length, // Log total lines found
          progressLinesFound: progressLines.length, // Log filtered count
        }
      );
      if (svgElement && progressLines.length !== 3) {
        console.log(
          "[IndexPopover] Current inner HTML of SVG:",
          svgElement.innerHTML
        );
      }
      return; // Stop if elements are missing
    }
    console.log(
      "[IndexPopover] All elements including 3 progress lines found successfully."
    );

    // --- State ---
    let isMenuExpanded = false;
    const collapsedWidth = "120px";
    const collapsedHeight = "44px";
    const collapsedBorderRadius = "22px";
    const expandedWidth = "240px";
    const expandedBorderRadius = "24px";
    // Get lengths directly from the filtered array
    const lineLengths = progressLines.map(
      (
        line // No type needed here either
      ) => parseFloat(line.dataset.length || "0")
    );
    let isScrolling = false;
    let scrollListenerActive = false;

    // --- Core Logic Functions (calculateSegmentFill, updateProgressLines, handleScroll, checkScrollabilityAndManageListener, toggleMenu) ---
    // These functions remain the same
    function calculateSegmentFill(
      overallScrollPercent,
      segmentStart,
      segmentEnd
    ) {
      if (overallScrollPercent <= segmentStart) return 0;
      if (overallScrollPercent >= segmentEnd) return 1;
      const segmentRange = segmentEnd - segmentStart;
      const progressInSegment = overallScrollPercent - segmentStart;
      return segmentRange > 0 ? progressInSegment / segmentRange : 0;
    }

    function updateProgressLines() {
      const element = document.documentElement;
      const scrollTop = element.scrollTop;
      const scrollHeight = element.scrollHeight;
      const clientHeight = element.clientHeight;
      const maxScroll =
        scrollHeight > clientHeight ? scrollHeight - clientHeight : 0;
      const scrollPercent =
        maxScroll > 0 ? Math.min(scrollTop / maxScroll, 1) : 0;

      progressLines.forEach((line, index) => {
        const dashLength = lineLengths[index];
        if (dashLength === 0) return;
        const startPercent = index / 3;
        const endPercent = (index + 1) / 3;
        const fillFraction = calculateSegmentFill(
          scrollPercent,
          startPercent,
          endPercent
        );
        const offset = dashLength * (1 - fillFraction);
        const clampedOffset = Math.max(0, Math.min(offset, dashLength));
        // Ensure line is treated as an HTMLElement for style access
        line.style.strokeDashoffset = clampedOffset.toString();
      });
      isScrolling = false;
    }

    function handleScroll() {
      console.log("[IndexPopover] Scroll event detected!");
      if (!isScrolling) {
        isScrolling = true;
        window.requestAnimationFrame(updateProgressLines);
      }
    }

    function checkScrollabilityAndManageListener() {
      const isScrollable =
        document.documentElement.scrollHeight >
        document.documentElement.clientHeight;
      console.log(
        `[IndexPopover] Checking scrollability: ${isScrollable ? "Yes" : "No"}`
      );
      if (isScrollable && !scrollListenerActive) {
        console.log("[IndexPopover] Attaching scroll listener to window.");
        window.addEventListener("scroll", handleScroll, { passive: true });
        scrollListenerActive = true;
        window.requestAnimationFrame(updateProgressLines);
      } else if (!isScrollable && scrollListenerActive) {
        console.log("[IndexPopover] Detaching scroll listener from window.");
        window.removeEventListener("scroll", handleScroll);
        scrollListenerActive = false;
        window.requestAnimationFrame(updateProgressLines);
      } else if (isScrollable && scrollListenerActive) {
        console.log("[IndexPopover] Scroll listener already active.");
        window.requestAnimationFrame(updateProgressLines);
      } else {
        console.log("[IndexPopover] Not scrollable and listener not active.");
        window.requestAnimationFrame(updateProgressLines);
      }
    }

    function toggleMenu(expand) {
      isMenuExpanded = expand;
      if (expand) {
        floatingMenu.style.width = expandedWidth;
        floatingMenu.style.borderRadius = expandedBorderRadius;
        floatingMenu.style.height = "auto";
        menuList.classList.add("visible");
        arrowIcon.classList.add("rotated");
      } else {
        const currentHeight = floatingMenu.scrollHeight + "px";
        floatingMenu.style.height = currentHeight;
        requestAnimationFrame(() => {
          floatingMenu.style.width = collapsedWidth;
          floatingMenu.style.borderRadius = collapsedBorderRadius;
          floatingMenu.style.height = collapsedHeight;
          menuList.classList.remove("visible");
          arrowIcon.classList.remove("rotated");
        });
      }
    }
    // --- End of Core Logic Functions ---

    // --- Event Listeners ---
    console.log("[IndexPopover] Setting up event listeners...");
    menuToggle.addEventListener("click", (event) => {
      event.stopPropagation();
      toggleMenu(!isMenuExpanded);
    });
    menuList.querySelectorAll("a[data-menu-link]").forEach((link) => {
      link.addEventListener("click", () => {
        if (isMenuExpanded) toggleMenu(false);
      });
    });
    document.addEventListener("click", (event) => {
      if (isMenuExpanded && !floatingMenu.contains(event.target)) {
        toggleMenu(false);
      }
    });
    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape" && isMenuExpanded) toggleMenu(false);
    });

    let resizeTimer;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        console.log("[IndexPopover] Resize detected.");
        // This function re-checks scrollability and attaches the listener if needed
        checkScrollabilityAndManageListener();
      }, 250);
    });
    console.log("[IndexPopover] Event listeners set up.");

    // --- Initial Setup ---
    console.log("[IndexPopover] Performing initial style setup...");
    floatingMenu.style.width = collapsedWidth;
    floatingMenu.style.height = collapsedHeight;
    floatingMenu.style.borderRadius = collapsedBorderRadius;

    checkScrollabilityAndManageListener();
    window.requestAnimationFrame(updateProgressLines); // Initial update

    console.log("[IndexPopover] Initialization complete.");
  } // End of setupIndexPopover function

  // --- Run Setup ---
  function runSetup() {
    // Keep a small delay
    const delay = 100;
    console.log(
      `[IndexPopover] Scheduling setup function with ${delay}ms delay.`
    );
    setTimeout(setupIndexPopover, delay);
  }

  if (document.readyState === "loading") {
    console.log("[IndexPopover] DOM not ready, waiting for DOMContentLoaded.");
    document.addEventListener("DOMContentLoaded", runSetup);
  } else {
    console.log("[IndexPopover] DOM ready, running setup soon (setTimeout).");
    runSetup();
  }
</script>
