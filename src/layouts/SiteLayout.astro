---
import Document from "@/layouts/Document.astro";
import Header from "@/components/site/Header.astro";
import Footer from "@/components/site/Footer.astro";
import { slide } from "astro:transitions";

interface Props {
  title?: string;
  description?: string;
}

const { title, description } = Astro.props;
const pageSlide = slide({ duration: "0.55s" });
---

<Document title={title} description={description}>
  <a
    href="#main-content"
    class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-200 focus:px-4 focus:py-2 focus:bg-background focus:text-foreground focus:ring-2 focus:ring-foreground focus:rounded"
  >
    Skip to content
  </a>

  <main class="relative flex flex-col min-h-screen w-full bg-background text-foreground">
    <Header />
    <div id="main-content" class="flex-1 w-full pt-20" transition:animate={pageSlide}>
      <slot />
    </div>
    <Footer />
  </main>

  <script is:inline>
    (() => {
      const setCollapseHeights = () => {
        document.querySelectorAll("details.collapsible").forEach((details) => {
          const inner = details.querySelector(":scope > .collapse-panel > .collapse-panel-inner");
          if (!inner) return;
          details.style.setProperty("--collapse-height", `${inner.scrollHeight}px`);
        });
      };

      const setupCollapsibles = () => {
        const collapseNodes = document.querySelectorAll("details.collapsible");
        if (!collapseNodes.length) return;

        collapseNodes.forEach((details) => {
          if (details.dataset.collapseBound === "true") return;
          details.dataset.collapseBound = "true";
          details.addEventListener("toggle", setCollapseHeights);
        });

        setCollapseHeights();
        requestAnimationFrame(setCollapseHeights);
      };

      const setupTextReveal = () => {
        const revealNodes = document.querySelectorAll("[data-text-reveal]");
        if (!revealNodes.length) return;

        if (window.matchMedia("(prefers-reduced-motion: reduce)").matches || !("IntersectionObserver" in window)) {
          revealNodes.forEach((node) => node.classList.add("is-visible"));
          return;
        }

        const observer = new IntersectionObserver(
          (entries, currentObserver) => {
            entries.forEach((entry) => {
              if (!entry.isIntersecting) return;
              entry.target.classList.add("is-visible");
              currentObserver.unobserve(entry.target);
            });
          },
          { threshold: 0.2, rootMargin: "0px 0px -12% 0px" },
        );

        revealNodes.forEach((node) => {
          if (!node.classList.contains("is-visible")) {
            observer.observe(node);
          }
        });
      };

      if (!window.__textRevealLifecycleBound) {
        document.addEventListener("astro:page-load", setupTextReveal);
        document.addEventListener("astro:page-load", setupCollapsibles);
        window.__textRevealLifecycleBound = true;
      }

      if (!window.__collapseResizeBound) {
        window.addEventListener("resize", setCollapseHeights);
        window.__collapseResizeBound = true;
      }

      setupCollapsibles();
      setupTextReveal();
    })();
  </script>
</Document>
